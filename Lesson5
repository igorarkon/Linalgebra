1. Найти с помощью NumPy SVD для матрицы

1 2 0 
0 0 5
3-4 2
1 6 5
0 1 0

import numpy as np
np.set_printoptions(precision=2, suppress=True)
A = np.array([[1, 2, 0],
              [0, 0, 5],
              [3, -4, 2],
              [1, 6, 5],
              [0, 1, 0]])

U, s, W = np.linalg.svd(A)

# Транспонируем матрицу W
V = W.T

# s - список диагональных элементов, его нужно привести к виду диагональной матрицы для наглядности
D = np.zeros_like(A, dtype=float)
D[np.diag_indices(min(A.shape))] = s


print(f'Матрица U:\n{U}')
# Убедимся, что она действительно ортогональна
print(np.dot(U.T, U))
print(f'Матрица V:\n{V}')
# Убедимся, что она действительно ортогональна
print(np.dot(V.T, V))
# Проведем проверку
print(np.dot(np.dot(U, D), V.T))

   
Матрица U:
[[ 0.17  0.16 -0.53 -0.8  -0.16]
 [ 0.39 -0.53  0.61 -0.43  0.03]
 [-0.14 -0.82 -0.52  0.14  0.07]
 [ 0.89  0.06 -0.25  0.38 -0.06]
 [ 0.08  0.11 -0.08 -0.11  0.98]]

[[ 1. -0.  0.  0.  0.]
 [-0.  1.  0. -0.  0.]
 [ 0.  0.  1.  0.  0.]
 [ 0. -0.  0.  1.  0.]
 [ 0.  0.  0.  0.  1.]]

Матрица V:
[[ 0.07 -0.37 -0.93]
 [ 0.72  0.67 -0.21]
 [ 0.69 -0.65  0.31]]

[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

[[ 1.  2. -0.]
 [-0.  0.  5.]
 [ 3. -4.  2.]
 [ 1.  6.  5.]
 [ 0.  1.  0.]]


2. Для матрицы из предыдущего задания найти:

а) евклидову норму;

б) норму Фробениуса.

A_evk = np.linalg.norm(A,ord=2)
A_frob = np.linalg.norm(A,ord='fro')
print(A_evk)
print(A_frob)

8.824868854820442
11.045361017187261

